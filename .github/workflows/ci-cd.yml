name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: "18"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Test Backend
  test-backend:
    runs-on: ubuntu-latest

    services:
      mongodb:
        image: mongo:7.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password123
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: server/package-lock.json

      - name: Install backend dependencies
        run: |
          cd server
          npm ci

      - name: Run backend linting
        run: |
          cd server
          npm run lint || echo "Linting not configured"

      - name: Run backend tests
        run: |
          cd server
          npm test || echo "Tests not configured"
        env:
          NODE_ENV: test
          MONGODB_URI: mongodb://admin:password123@localhost:27017/police-fine-system-test?authSource=admin
          JWT_SECRET: test-secret-key

  # Test Frontend
  test-frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: client/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd client
          npm ci

      - name: Run frontend linting
        run: |
          cd client
          npm run lint || echo "Linting not configured"

      - name: Run frontend tests
        run: |
          cd client
          npm test -- --coverage --watchAll=false || echo "Tests not configured"

      - name: Build frontend
        run: |
          cd client
          npm run build
        env:
          CI: ""
          REACT_APP_API_URL: http://localhost:5000
          REACT_APP_STRIPE_PUBLISHABLE_KEY: pk_test_dummy
          REACT_APP_GOOGLE_MAPS_API_KEY: dummy_key

  # Security Scan
  security-scan:
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    if: false # temporarily disabled
    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@v0
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: ${{ always() && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
        with:
          sarif_file: "trivy-results.sarif"

  # Build and Push Docker Images
  build-and-push:
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        service: [backend, frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service == 'backend' && 'server' || 'client' }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL || 'http://localhost:5000' }}
            REACT_APP_STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }}
            REACT_APP_GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}

  # Deploy to AWS ECS (Production)
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/main'
    environment: production
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsECSDeployRole
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS
        run: |
          # Update ECS service with new image
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_SERVICE_NAME }}-backend \
            --force-new-deployment

          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_SERVICE_NAME }}-frontend \
            --force-new-deployment

      - name: Debug ECS service
        run: |
          set -e
          CL=${{ secrets.ECS_CLUSTER_NAME }}
          BASE=${{ secrets.ECS_SERVICE_NAME }}

          for SVC in backend frontend; do
            echo "=== Describe service: $BASE-$SVC ==="
            aws ecs describe-services --cluster "$CL" --services "$BASE-$SVC" | jq '.services[0] | {status, desiredCount, runningCount, pendingCount}'
            echo "=== Recent events: $BASE-$SVC ==="
            aws ecs describe-services --cluster "$CL" --services "$BASE-$SVC" --query 'services[0].events[0:10].[createdAt,message]' --output table || true

            RUN=$(aws ecs list-tasks --cluster "$CL" --service-name "$BASE-$SVC" --desired-status RUNNING --query 'taskArns' --output text || true)
            STOP=$(aws ecs list-tasks --cluster "$CL" --service-name "$BASE-$SVC" --desired-status STOPPED --query 'taskArns' --output text || true)

            if [ -n "$RUN" ]; then
              echo "=== Describe RUNNING task ==="
              aws ecs describe-tasks --cluster "$CL" --tasks $RUN --query 'tasks[0].[lastStatus,containers[0].lastStatus,containers[0].networkBindings,containers[0].reason]' --output table || true
            fi
            if [ -n "$STOP" ]; then
              echo "=== Describe STOPPED task ==="
              aws ecs describe-tasks --cluster "$CL" --tasks $STOP --query 'tasks[0].[stoppedReason,containers[0].exitCode,containers[0].reason,containers[0].lastStatus]' --output table || true
            fi
          done

          echo "=== Recent backend logs (if log group exists) ==="
          aws logs filter-log-events --log-group-name "/ecs/${BASE}-backend" --max-items 100 --query 'events[].message' --output text || true
          echo "=== Recent frontend logs (if log group exists) ==="
          aws logs filter-log-events --log-group-name "/ecs/${BASE}-frontend" --max-items 100 --query 'events[].message' --output text || true

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_SERVICE_NAME }}-backend ${{ secrets.ECS_SERVICE_NAME }}-frontend

  # Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsECSDeployRole
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to Staging ECS
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }}-staging \
            --service ${{ secrets.ECS_SERVICE_NAME }}-backend-staging \
            --force-new-deployment

          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }}-staging \
            --service ${{ secrets.ECS_SERVICE_NAME }}-frontend-staging \
            --force-new-deployment

  # Notify on Success/Failure
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-production, deploy-staging]
    if: always()

    steps:
      - name: Notify Slack on Success
        if: ${{ needs.deploy-production.result == 'success' || needs.deploy-staging.result == 'success' }}
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "Deployment successful! üéâ"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Failure
        if: ${{ needs.deploy-production.result == 'failure' || needs.deploy-staging.result == 'failure' }}
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "Deployment failed! ‚ùå"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
